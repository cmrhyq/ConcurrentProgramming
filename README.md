# Concurrent Programming
[toc]

## 相关链接

[Java并发编程](https://juejin.cn/book/7116420171471781903/section/7116518259658063884?utm_source=post_pay_page)

## CPU的构成

![image-20230223004939098](https://image.kevinkda.cn/md/image-20230223004939098.png)

### 寄存器

​	寄存器中主要存储了从内存中加载的数据，寄存器的运行速度比内存快了好多个级别， 准确的说是从内存中将数据加载到L1，L2，L3缓存，再到寄存器中。而我们编写的程序在计算机底层转换为汇编语言之后，主要操作的对象就是寄存器。例如常见的mov和add指令

```assembly
mov eax, DWORD PTR i[rip]
add eax, 1
mov DWORD PRT i[rip], eax
```

​	寄存器按照存储的数据可分为两大类：存储内存地址类寄存器、存储非内存地址类寄存器。

 - 存储内存地址类寄存器
    - 程序计数器、基址寄存器、变址寄存器
- 存储非内存地址类寄存器
  - 累加寄存器、通用寄存器、标志寄存器

![image-20230223004907486](https://image.kevinkda.cn/md/image-20230223004927545.png)

### 控制器

​	控制器主要是起到一个辅助的功能，它可以帮助CPU做一些指令读取，结果写回等功能，同时它也能根据汇编指令的结果去操控一些计算机的硬件设备。

### 运算器

​	运算器是CPU内部最核心的用于做计算的模块，我们编写的程序在经过多步编译之后最终传达给到CPU的会是一段0和1组成的指令代码，这些指令在控制器的帮助下会将需要计算的数据放入到寄存器中，让运算器去计算。

###  时钟

​	主要是用于记录每次CPU计算的耗时，它的运算单位为ghz，1ghz = 10亿次/秒，通常ghz越高，表示CPU的运算效率越高。

### 寄存器和程序之间的关系

```java
public class CountDemo {

    public static void compareTest(int a, int b, int[] arr) {
        int t1 = countSum(a);
        int t2 = countSum(b);
        if (t1 > t2) {
            arr[0] = 1;
        } else {
            arr[1] = 1;
        }
    }

    //1～a的求和计算
    public static int countSum(int a) {
        int sum = 0;
        for (int i = 1; i <= a; i++) {
            sum += i;
        }
        return a;
    }

    public static void main(String[] args) {
        int a[] = {-1,-1};
        compareTest(1, 2, a); // ----- code_1
    }
    
}
```

​	这段程序在IDE开发完成之后，实际上会保存到磁盘当中

![image-20230223004927545](https://image.kevinkda.cn/md/image-20230223004907486.png)

​	接着如果要运行程序，可以输入Java指令去运行它，例如：javac和java指令。接下来磁盘中的程序会被读取到内存当中，并且进行相关的编译工作。期间涉及到多次编译，会在jvm层变成class字节码，然后再转换成汇编指令，最后才是机器码（这也是了解了将Java代码转成汇编指令才能认清它背后的原因了）。

![image-20230223011546110](https://image.kevinkda.cn/md/image-20230223011546110.png)

​	这些机器码存放的**地址**会被放到**程序计数器**的寄存器中，之后**控制器**会到根据程序计数器的地址去读取相关机器指令，并且将指令读取给**运算器**进行计算。当运行结束以后，**程序计数器的地址就会刷新，让控制器去加载新内存地址的指令给到运算器。**

![image-20230223011307830](https://image.kevinkda.cn/md/image-20230223011307830.png)

​	上方的CountDemo这段代码中虽然涉及到了求和计算、比较计算、函数调用三个功能，但是在实际过程中却涉及到了前面提到的六种寄存器。

​	首先main函数执行，**程序计数器的地址**会更新为main函数**入口的位置**，让控制器去加载其指令地址开始执行。接着在准备调用compareTest函数的时候，会有一条call指令将当前的程序计数器地址变更为子函数的入口，同理，在compareTest函数内部带哦用countSum函数也是会发送call指令。当子函数执行结束后，便执行一条return指令，返回原先执行代码位置的下一条指令位置。

​	countSum内部，会发现函数包含了求和累计的计算，这里面涉及到累加寄存器和标志寄存器的使用。**累加寄存器就是将sum的数值在累加寄存器中不断更新**。**而标志寄存器是用于判断是否满足跳出循环的逻辑**。

​	在for循环中编写的 i<=a; 这个逻辑，而计算机底层会通过做差的方式来判断是否满足该条件，也就是变成了 a - i >= 0; 的判断。通过a-i计算出来的结果会被记录到**标志寄存器**的某些个位上。

![image-20230223012739954](https://image.kevinkda.cn/md/image-20230223012739954.png)

​	**标志寄存器**可以理解为是一个巨大的bit数组，不同位置上的bit值代表了不同的涵义，当需要将计算的结果记录为负的话，只需要将bit[0]更新为1即可。

​	**变址寄存器**和**基址寄存器**，这两个寄存器主要的作用就是在数组进行元素定位的过程中会有所使用。

![image-20230223013045624](https://image.kevinkda.cn/md/image-20230223013045624.png)

​	CPU在对数组这类数据结构的内部元素进行定位的时候会通过基址寄存器的位置+变址寄存器的数值进行查询，变址寄存器的类似于数据的索引下标，通过一个相对偏差数值去对具体位置的定位。

​	通用寄存器可以理解为专门用于存储一些临时变量的公共区域，例如一些临时定义的数字值。

## 临界区